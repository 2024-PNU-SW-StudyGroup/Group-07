# 1. 쿠키와 세션

HTTP는 기본적으로 무상태성 구조이다.
따라서 서버는 클라이언트를 매번 식별해야 하는데 이를 보완하기 위해 쿠키와 세션을 사용한다.

## 쿠키

쿠키는 클라이언트에서 저장하는 키-값 데이터 저장 구조이다.
서버에서 쿠키를 생성하여 클라이언트에 전달하면 클라이언트는 이를 저장하고 있다가 요청 시 쿠키를 함께 보낸다.
클라이언트가 사용자 정보를 저장하고 있으므로 보안 측면에서 좋지 않다.

## 세션

쿠키와 달리 서버에서 정보를 관리한다.
클라이언트를 구별하기 위해 세션 ID를 부여하여 클라이언트마다 고유의 세션 저장소를 가진다.
서버에서 사용자 정보를 저장하고 있으므로 보안 측면에서 좋지만 서버의 자원을 차지한다는 단점이 있다.

---

# 2. JWT 토큰

JWT 토큰은 전자 서명 방식을 사용한다.
누구나 JWT 토큰 정보를 볼 수 있지만 이를 수정하기 위해서는 서버의 비밀키가 필요하다.
JWT 토큰은 토큰의 타입과 서명 알고리즘을 명시한 **헤더**, 실제 데이터가 포함된 **페이로드**, 토큰이 변조되지 않았음을 검증할 수 있는 **서명**으로 구성되어 있다.

페이로드에는 이 토큰을 가지고 있는 사람은 누구인지, 어떤 권한을 가지는지, 만료 시각은 언제인지에 대한 정보를 가지고 있다.
클라이언트가 이를 서버에 전송하면 서버는 변조 여부를 확인하고 이상이 없으면 정상적으로 처리하는 방식이다.

JWT 토큰은 서버에 상태를 저장하지 않으므로 서버 리소스 절약, 스케일 아웃에 유리한 장점이 있다.
하지만 JWT 토큰 자체가 탈취되면 만료 시간까지 이를 막을 방법은 없다.

## Access, Refresh 토큰 

유효 기간을 짧게 하면 탈취 시 피해를 최소화할 수 있지만 사용자 불편도 증가한다.
이 경우 유효 기간이 다른 두 토큰을 도입하여 해결할 수 있다.
Access 토큰은 유효 기간이 짧고 Refresh 토큰은 유효기간이 길다.

1. 처음 로그인하면 두 토큰을 받는다.
2. 클라이언트 인증이 필요할 때는 Access Token을 사용한다.
3. Access Token이 시간이 경과하여 만료되면 Refresh Token을 넣어 API를 재요청한다.
4. Refresh Token의 신원이 확인되면 새로운 Access Token을 발급한다.

자주 통신이 이루어지는 Access 토큰이 탈취될 위험이 높지만 이는 유효기간이 짧다.
그리고 탈취될 위험이 적은 Refresh 토큰은 유효기간이 길어 Access 토큰 탈취 시 피해를 최소화하면서 사용자의 편의성을 증가할 수 있다.

하지만 Refresh 토큰이 탈취되었다면 이를 막을 수 있는 방법은 없다.
이를 해결하기 위해 새로 Access Token을 발급받을 때 Refresh Token도 새로 발급받는 것이다.
이렇게 하면 Refresh Token을 일회용으로 사용하여 Refresh Token 탈취 위험을 최소화할 수 있다.
하지만 서버에서 Refresh Token이 만료되었다는 정보를 따로 저장하고 있어야 한다는 단점이 존재한다.

---

# 3. REST

REpresentational State Transfer의 약자로 분산 하이퍼미디어 시스템을 위한 아키텍처 스타일이다.
특정 제약 조건을 적용하여 웹 상호작용을 효율적으로 설계할 수 있다. 
REST 아키텍쳐에서는 컴포넌트(=서버, 클라이언트)의 독립적인 배포, 중개 컴포넌트(프록시, 캐시 등)을 활용한 성능 최적화를 강조한다.

## RESTful API

RESTful API는 REST 아키텍쳐 스타일을 따르는 API를 의미한다.

---

# 4. REST 제약 사항

REST 아키텍처는 다음과 같은 제약 사항을 준수해야 한다.

## 클라이언트 서버 구조

클라이언트와 서버는 각각 독립적으로 확장할 수 있다.

## 무상태성

서버는 클라이언트 상태를 저장하지 않는다. 서버의 자원 관리가 간소화되고 복구가 쉬워진다.

## 캐시 가능성

응답 데이터는 캐시를 할 수 있어 성능을 향상시킬 수 있다.

## 균일한 인터페이스

컴포넌트 간의 상호작용을 단순하고 일관성 있게 유지하기 위함이다.

- 리소스 식별: 요청은 서로 다른 리소스를 식별할 수 있어야한다.
- 표현을 통한 리소스 조작: 클라이언트가 원할 때 리소스 표현(HTTP 메세지, 파일 등)으로 리소스를 조작할 수 있다.
- 자체 설명 메세지: 클라이언트는 표현을 추가로 처리하는 방법에 대한 정보를 서버로부터 수신한다.
- 하이퍼미디어: 클라이언트는 작업을 완료하는데 필요한 다른 모든 리소스에 대한 정보를 하이퍼링크로 받을 수 있다.

## 계층화된 시스템

여러 계층으로 구성되어 클라이언트는 중간 계층(프록시, 로드밸런서) 등을 통과해 서버와 통신할 수 있으며 각 계층은 독립적으로 확장할 수 있다.

---

# 5. URL, URI, URN

## URI

> Uniform Resource Identifier

인터넷에 있는 리소스 자체를 식별하는 방법이다.

## URL

> Uniform Resource Locator

자원이 어디에 있는지 위치를 알려주기 위한 규약이다.
URL은 리소스의 경로를 명시하여 해당 리소스를 식별하고 접근할 수 있는 방법을 제공한다.
클라이언트가 서버에게 내가 찾는 리소스의 위치를 전달하면 서버가 이 위치에 해당하는 리소스를 반환한다.

## URN

> Uniform Resource Name

`urn:isbn:0451450523`

리소스의 위치가 아닌 이름을 부여하는 규약이다.
클라이언트가 서버에게 내가 찾는 리소스의 이름을 전달하면 서버가 이를 적절한 방법으로 찾아 반환하는 방식으로 활용할 수 있다.
urn을 바탕으로 리소스에 접근하기 위해서는 추가적인 구현이 필요하므로 일반적으로 식별과 해당 위치로의 접근이 모두 가능한 URL이 선호된다.

---

# 6. SOP, CORS

## SOP(Same-Origin Policy)

자바스크립트 엔진의 표준 스펙에 있는 보안 규칙으로 하나의 출처에서 불러온 리소스는 동일한 출처의 다른 리소스에만 접근할 수 있다.
따라서 리소스 간의 상호작용에서는 동일한 출처만 허용하는 것이다.
예를 들어 `http://hello.com` 웹 페이지는 SOP에 의해 `http://hello.com` 내의 리소스에만 접근할 수 있다.
`http://hello.com` 웹 페이지가 `http://hello2.com`의 리소스를 가져온다면 이 때는 SOP에 의해 차단된다.

이러한 SOP가 도입된 이유는 보안 위협 때문이다.
한 리소스가 출처가 다른 리소스와 통신하는데 제약이 없다면 리소스를 소유하는 애플리케이션이 악성 애플리케이션일 경우 민감한 정보가 누출되는 문제가 발생할 수 있다.
SOP는 브라우저에서 구현된 스펙으로 한 리소스와 연관된 다른 리소스가 다른 출처일 경우 브라우저는 다른 출처 리소스에 대한 요청을 보내지 않고 에러를 발생시킨다.

브라우저에서 다른 출처 리소스의 요청을 차단하기 때문에 **서버에서 다른 출처 리소스를 요청하고 받아 이를 클라이언트에 함께 전송하는 것은 SOP로 차단할 수 없다.**


### 동일 출처 기준

scheme과 domain, 포트 모두 일치해야 한다.
`https://www.naver.com` 내의 리소스는 다른 리소스와 어떠한 제약 없이 상호작용할 수 있다.

### SOP 정책
- form: 다른 출처로 데이터 전송 가능
- image: 다른 출처의 이미지 삽입 가능
- script: 다른 출처의 스크립트의 삽입 자체는 가능하지만 이 스크립트로 다른 출처로 요청을 보낼 수는 없다

## CORS(Cross Origin Resource Sharing)

SOP를 완벽히 준수하면서 모든 비즈니스 요구 사항을 만족시키기는 불가능하다.
필요에 따라 외부의 리소스를 가져와야 하는 경우도 있고 비즈니스 규모가 커짐에 따라 여러 서버에 리소스가 분산되어 있는 경우가 있기 때문이다.
이 경우 외부 리소스와 상호작용을 하기 위해서는 CORS 설정을 해주어야 한다.

외부 리소스가 나의 리소스에 접근하는 것을 허용하도록 하고 싶다면 Access-Control-Allow-Origin에 접근을 허용할 다른 리소스의 출처를 표시한다.
A와 연관된 객체 B가 서로 다른 출처에 있다면 브라우저는 A와 B를 요청한 후 A의 출처와 B의 응답 헤더의 Access-Control-Allow-Origin이 동일하다면 가져오고 그렇지 않다면 B의 요청을 버리고 CORS 에러를 발생시킨다.

### 예비 요청 방식

연관된 객체 B에 악성 데이터가 포함될 수 있기 때문에 OPTIONS를 이용하여 예비 요청을 보내 Access-Control-Allow-Origin을 먼저 확인한다고 생각하면 된다.
예비 요청에서 이 요청이 안전하다고 판단되면 전체 데이터를 요청하게 된다.
이 예비 요청을 일정 시간동안 캐싱해서 클라이언트와 서버 간 RTT를 줄일 수 있다.

### 단순 요청 방식

예비 요청을 보내지 않고 바로 서버에 본 요청을 보내는 방식이다.
다음과 같은 조건일 때 예비 요청을 보내지 않고 본 요청을 보낸다.

- GET, HEAD, POST 메서드여만 한다.
- 특정 헤더(Accep, Content-Type 등)만 포함되어 있어야 한다.
- Content-Type 헤더의 값이 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나여야 한다.

### 인증 요청 방식

클라이언트가 서버에게 인증 정보를 포함하여 요청할 때 사용된다.
요청에 인증과 관련된 정보를 담을 수 있도록 세가지 옵션이 존재한다.

- same-Origin(기본값): 같은 출처 간 요청에만 인증 정보를 담을 수 있다.
- include: 모든 요청에 인증 정보를 담을 수 있다.
- omit: 모든 요청에 인증 정보를 담지 않는다.

인증 정보를 교환하는 경우 서버가 허용할 Origin을 지정할 때 와일드카드("*")를 사용할 수 없다.
인증 정보는 여러 서버 간 무분별하게 공유를 할 때 위험하므로 이러한 제약 사항이 붙은 것이다.

- Access-Control-Allow-Credentials를 true로 설정해야 한다.
- Access-Control-Allow-Origin 값에 "*"는 사용할 수 없다.

---

# 7. XSS 공격

> Cross Site Scripting

웹 사이트에 악성 스크립트를 주입하여 사용자들의 개인 정보를 빼내는 것이 목적이다.

1. 사용자가 입력한 내용을 그대로 표시해주는 게시판과 같은 웹 서비스에 악성 스크립트를 삽입한다.
2. 피해자가 게시글을 클릭하면 악성 스크립트가 실행되어 피해자의 쿠키 값을 공격자에게 전송하도록 설정되어 있다.

또는 웹 애플리케이션에서 XSS 취약점을 파악해 웹 애플리케이션의 데이터베이스에 악성 스크립트를 삽입할 수 있다.
이 경우 지속적으로 사용자의 정보가 누출이 되며 많은 피해가 발생할 수 있다.

XSS를 예방하기 위해서는 특수 문자를 입력받지 못하도록 하는 방식들을 통해 스크립트로 변환될 수 있는 부분을 필터링해야 한다.

---

# 8. CSRF 

> Cross Site Request Forgery

웹 애플리케이션이 정상적인 요청과 피해자가 의도하지 않은 요청을 구분하지 못하는 점을 악용하는 공격 방식이다.
CSRF는 **사용자의 인증 정보**를 바탕으로 공격한다.

1. `http://bank/send/{id}` 는 id에게 돈을 보내는 API라고 하자.
2. 이 때 공격자는 로그인된 피해자에게 이 링크를 클릭하도록 유도한다.
3. 피해자가 로그인되어 있다면 서버는 피해자가 이 요청을 수행한 것이라 판단해 실제로 돈이 빠져나가게 된다.

## 예방

이를 예방하기 위해서는 어떠한 요청이 의도한 요청인지 그렇지 않은 요청인지 구불할 수 있어야 한다.
이를 위해 서버에서 허용한 화면에서 수행한 사용자 요청만 의도한 요청인지 판단하는 방법이 있다.
1. 서버에서 웹 페이지를 클라이언트로 전송할 때 랜덤으로 생성되는 토큰을 함께 보낸다.
2. 이후 사용자가 요청을 보낼 때 토큰을 담아 전송하여 보낼 때 토큰과 받은 토큰이 일치하는지 비교한다.
3. 일치한다면 사용자가 유효한 웹 페이지 내에서 요청을 전송하여 의도한 요청이라고 판단하고 통과한다.
4. 일치 여부를 파악하면 토큰은 바로 폐기한다.

---

# 9. SQL Injection

사용자 입력을 데이터베이스에 저장하는 폼 입력 등에 SQL 구문을 전송함으로써 악의적인 SQL 쿼리가 실행되도록 한다.

```sql
SELECT * FROM Users WHERE id = 'input'
```

이 때 input에 `1' OR 1=1 --` 입력이 들어가면 모든 사용자 정보를 조회할 수 있게 된다.

```sql
SELECT * FROM Users WHERE id = '1' OR 1=1 --'
```

## 예방

XSS처럼 사용자 입력의 검증이 가장 중요하다.
java의 PreparedStatement는 SQL 문법 파싱 과정을 단 한번만 수행하고 이후 파싱한 결과를 보관했다가 사용자 입력 변수를 나중에 바인딩해서 사용한다.
PreparedStatement는 이미 문법 파싱 과정을 거쳤기 때문에 문법을 조작하는 악성 입력이 들어와도 파싱되지 않아 문법적인 의미를 가지지 않는다.

---

# 10. 웹 캐시

동일한 웹 페이지를 여러 번 접속할 때 접속할 때마다 서버에서 가져오지 않고 캐시함으로써 성능을 향상시킬 수 있다.

- 브라우저 캐시: 개인에 한정된 캐시로 브라우저에 캐싱을 한다.
- 프록시 캐시: 클라이언트와 서버 사이에서 동작하며 웹 서버의 컨텐츠를 클라이언트와 가까운 지점에 캐싱한다.

## 캐시 동기화

캐시를 하면 이 캐시가 정말 최신 데이터가 맞는지 검증하는 과정이 필요하다.
캐시에는 유효기간이 있어 짧게 설정하면 빠르게 갱신이 가능하지만 너무 짧다면 성능상 이점이 없을 것이다.
반대로 너무 길게 설정하면 최신 데이터가 전혀 반영되지 않을 것이다.

따라서 컨텐츠의 업데이트 속도 등을 감안하여 TTL(Time To Live)를 적절히 설정하여 TTL이 지난 리소스라면 다시 서버에서 데이터를 가져오도록 설정할 수 있다.

---

# 11. 프록시 서버

프록시 서버는 서버와 클라이언트 사이에 존재하는 컴퓨터 시스템으로 클라이언트의 요청을 대신 처리한다.
클라이언트가 서버에게 요청을 바로 보내는 것이 아니라 클라이언트가 프록시 서버로 전달하면 프록시 서버는 이를 서버로 전달한다.
이런 방식을 사용하면 서버는 프록시 서버만 인지할 수 있고 어떤 클라이언트가 요청을 보냈는지 알 수 없다.
이렇게 **서버가 어떤 클라이언트가 보냈는지 알 수 없도록 프록시가 대신 요청을 보내는 방식을 포워드 프록시**라고 한다.

반대로 서버에 바로 접속할 수 없고 클라이언트는 서버 바로 앞단에 있는 프록시에게 요청을 보내면 프록시가 적절히 서버와 통신하고 그 결과를 클라이언트에게 반환한다
이런 방식을 사용하면 클라이언트는 프록시 서버만 인지할 수 있고 어떤 서버가 요청을 처리했는지 알 수 없다.
이렇게 클라이언트가 어떤 서버에게 요청을 보냈는지 알 수 없도록 프록시가 대신 요청을 처리하는 방식을 리버스 프록시**라고 한다.

## 포워드 프록시

포워드 프록시는 클라이언트의 요청을 대신 처리함으로써 다음과 같은 장점이 있다.
1. 클라이언트의 IP를 숨길 수 있다.
2. 클라이언트가 포워드 프록시를 통해서만 외부에 요청을 하므로 악성 웹사이트 접근을 포워드 프록시에서 막을 수 있다.
2. 포워드 프록시가 데이터를 캐싱하여 제공할 수 있다.

## 리버스 프록시

리버스 프록시는 서버의 요청을 대신 처리함으로써 다음과 같은 장점이 있다.
1. 서버의 IP를 숨길 수 있다.
2. 리버스 프록시가 데이터를 캐싱하여 제공할 수 있다.
3. 리버스 프록시에서 TLS 암호화를 해제하여 서버에서 TLS 암호화로 인한 오버헤드를 줄일 수 있다.

---

# 12. L7 로드밸런서

L7 로드밸런서는 IP와 Port 만으로 로드 밸런싱을 하는 L4 로드밸런서와 달리 Application Layer가 제공하는 다양한 정보를 바탕으로 세밀한 로드밸런싱을 할 수 있다.
L7 로드밸런서는 다음과 같은 장점이 있다.

1. HTTP 프로토콜을 바탕으로 파이프라이닝, 멀티플렉싱 지원 가능
2. IP주소 + 포트 번호 + 패킷 내용을 보고 트래픽 분산 가능
3. TLS, SSL 설정 가능

## NGINX

NGINX는 리버스 프록시 + L7 로드밸런서라고 할 수 있다.
서버의 앞단에서 요청을 받아 이를 적절히 분산하는 역할을 한다.
HTTP 요청 URL을 확인하여 적절한 서버에 이 요청을 전달할 수 있다.

예를 들면 `http://hello.com/1` 이면 프론트엔드 서버에 전달하고 `http://hello.com/api/1` 이면 백엔드 서버에 전달할 수 있다.

---

# 13. 커넥션 타임아웃, 리드 타임아웃

- 커넥션 타임아웃: 처음 커넥션을 생성할 때 허용할 수 있는 최대 시간
- 리드 타임아웃: 데이터의 요청과 응답에서 허용할 수 있는 최대 시간

---

# Reference

[https://velog.io/@chuu1019/Access-Token%EA%B3%BC-Refresh-Token%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C](https://velog.io/@chuu1019/Access-Token%EA%B3%BC-Refresh-Token%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C)

[https://interconnection.tistory.com/74](https://interconnection.tistory.com/74)

[https://aws.amazon.com/ko/what-is/restful-api/](https://aws.amazon.com/ko/what-is/restful-api/)

[https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)

[https://velog.io/@jesop/SOP%EC%99%80-CORS](https://velog.io/@jesop/SOP%EC%99%80-CORS)

[https://nordvpn.com/ko/blog/xss-attack/](https://nordvpn.com/ko/blog/xss-attack/)

[https://nordvpn.com/ko/blog/csrf/](https://nordvpn.com/ko/blog/csrf/)

[https://blog.naver.com/skinfosec2000/220482240245](https://blog.naver.com/skinfosec2000/220482240245)

[https://etloveguitar.tistory.com/136](https://etloveguitar.tistory.com/136)