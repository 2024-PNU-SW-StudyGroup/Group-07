## 네트워크 2주차 > Application Layer 1

## > HTTP

### 1. HTTP 프로토콜에 대해서 설명해주세요.
> HTTP 프로토콜은 웹에서 클라이언트와 서버 간의 통신을 담당하는 규칙이다.
> 클라이언트가 HTTP 메서드로 서버에게 요청을 보내면, 서버는 그에 대해 HTTP 상태코드로 응답하는 방식으로 동작한다.
> 주로 비연결적이고 무상태(stateless) 방식으로 운영된다.

<br>

### 2. HTTP의 요청/응답 모델에 대해 설명해주세요.
> HTTP의 요청/응답 모델은 클라이언트가 서버에 요청을 보내고, 서버가 그 요청에 대한 응답을 반환하는 방식이다.
> 클라이언트는 요청 메세지를 통해 필요한 리소스를 요청하고, 서버는 해당 리소스를 포함하거나 처리 결과를 응답 메세지로 제공한다.

<br>

### 3. HTTP 메서드 중 GET과 POST의 차이점에 대해 설명해주세요.
> - GET: 주로 데이터를 요청할 때 사용되며, 데이터를 URL에 쿼리스트링 형태로 전달한다. 
> - POST: 서버에 데이터를 전송할 때 사용되며, 데이터는 HTTP 바디에 포함된다.

<br>

### 4. HTTP 메서드 중 PUT과 PATCH의 차이점에 대해 설명해주세요.
> - PUT: 자원의 전체 업데이트를 위해 사용되며, 지정된 URL에 자원의 전체 내용을 새로 작성한다.
> - PATCH: 자원의 일부만 수정할 때 사용되며, 지정된 URL의 일부만 변경합니다.

<br>

### 5. HTTP 상태 코드가 무엇인가요? 알고 있는 상태 코드 몇 가지 설명해주세요.
> HTTP 상태 코드는 클라이언트의 요청에 대한 서버의 응답 상태를 나타낸다.
> - 200 OK: 요청이 성공적으로 처리
> - 500 Internal Server Error: 서버에서 오류가 발생하여 요청을 처리할 수 없음
> - 401 Unauthorized : 요청이 인증되지 않아 접근이 거부됨

<br>

### 6. HTTP 헤더가 뭘까요? 알고 있는 헤더 몇 가지 설명해주세요.
> HTTP 헤더는 클라이언트와 서버가 주고받는 요청과 응답 메시지에 대한 메타데이터를 포함하는 부분이다.
> 다양한 정보를 전달할 수 있으며, 요청/응답에 영향을 미친다.
> - Content-Type: 전송되는 데이터의 타입을 명시 (예: application/json, text/html)
> - Authorization: 클라이언트 인증을 위한 토큰을 포함
> - User-Agent: 요청을 보내는 클라이언트의 애플리케이션 정보를 포함

<br>

### 7. HTTP의 무상태성에 대해서 설명해주세요.
> HTTP는 무상태(stateless) 프로토콜이다.
> 즉, 클라이언트와 서버 간의 각각의 요청은 독립적이며 이전 요청의 정보를 기억하지 않는다.
> 서버는 클라이언트의 상태를 유지하지 않으며, 각 요청마다 모든 필요한 정보를 포함해야 한다.

<br>

### 8. HTTP Keep-Alive에 대해서 설명해주세요.
> HTTP Kepp-Alive는 연결을 유지하여 여러 요청과 응답을 같은 TCP 연결에서 처리할 수 있도록 하는 기능이다.
> 기본적으로 HTTP는 요청 후 연결을 닫지만, Keep-Alive를 사용하면 클라이언트와 서버간의 연결을 계속 유지하여, 추가 요청이 있을 때 새로운 연결을 설정할 필요 없이 데이터를 전송할 수 있다.
> 이로 인해 성능이 향상되고, 네트워크 자원 소모가 줄어든다.

<br>

### 9. HTTP 파이프라이닝에 대해서 설명해주세요.
> HTTP 파이트라이닝은 하나의TCP 연결을 통해 여러 HTTP 요청을 연속적으로 보내고, 서버가 순차적으로 응답하는 기술이다.
> 이를 통해 요청과 응답 간의 지연을 줄이고, 성능을 개선할 수 있다. 
> 클라이언트는 요청을 순서대로 보내고, 서버는 각 요청에 대한 응답을 동일한 순서로 반환한다.

<br>

### 10. HTTP/1.1, HTTP/2, HTTP/3 각각의 특징에 대해 설명해주세요.
> - HTTP/1.1: 기본적인 버전으로, Keep-Alive를 도입하여 연결 재사용을 지원. 그러나 요청-응답 순차 처리로 인한 지연 문제.
> - HTTP/2: 멀티플렉싱을 통해 여러 요청을 동시에 처리할 수 있으며, 헤더 압축으로 성능 개선.
> - HTTP/3: 기존의 TCP 대신 QUIC 프로토콜을 사용하여 전송 지연을 줄이고, 보안을 강화한 버전.

<br>

## > HTTPS

### 11. HTTPS에 대해서 설명해주세요.
> HTTPS(Hypertext Transfer Protocol Secure)는 HTTP에 SSL/TLS 암호화가 추가된 프로토콜이다.
> 클라이언트와 서버간의 데이터를 암호화하고, 중간에 제 3자가 데이터를 엿보거나 변조하는 것을 방지한다.

<br>

### 12. SSL/TLS가 무엇인가요?
> SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 네트워크 통신을 암호화하여 보안을 강화하는 프로토콜이다.
> SSL은 초기 버전이며, 현재는 보안 강화를 위해 TLS가 사용된다.
> 둘다 HTTPS와 같은 프로토콜에서 사용된다.

<br>

### 13. 대칭키 암호화 방식에 대해 설명해주세요.
> 대칭키 암호화 방식은 데이터 암호화와 복호화에 동일한 키를 사용하는 방식이다.
> 송신자와 수신자는 같은 비밀 키를 사용하여 데이터를 암호화하고 복호화한다.
>
> ❕대칭키 암호화 방식 특징
> - 키 공유: 송신자와 수신자는 동일한 비밀 키를 공유해야 한다.
> - 속도: 대칭키 암호화는 상대적으로 빠른 처리 속도를 제공한다.
> - 보안 문제: 키가 유출되면 데이터의 보안이 위험해질 수 있다. 

<br>

### 14. 비대칭키 암호화 방식에 대해서 설명해주세요.
> 비대칭키(공개키) 암호화 방식은 데이터 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 방식이다. 이 두 키는 공개키와 개인키로 구분된다.
>
> ❕비대칭키 암호화 방식 특징
> - 공개키와 개인키: 공개키는 암호화를 위해 공개적으로 배포되며, 개인키는 비밀로 유지된다. 암호화는 공개키로, 복호화는 개인키로 수행된다.
> - 보안: 공개키로 암호화된 데이터는 대응하는 개인키로만 복호화할 수 있다. 반대로, 개인키로 서명된 데이터는 공개키로만 검증할 수 있다.
> - 키 관리: 비대칭키 방식은 키 배포 문제를 해결하지만, 대칭키보다 처리 속도가 느릴 수 있다.

<br>

### 15. 전자 서명에 대해서 설명해주세요.
> 전자 서명은 데이터의 무결성과 인증을 보장하는 방법으로, 송신자가 자신의 개인키로 데이터를 서명하면 수신자는 송신자의 공개키로 이를 검증한다. 이를 통해 데이터가 변조되지 않았음을 확인할 수 있다.
>
> 1. 해시 생성 : 문서의 해시값(고정 길이의 요약 값)을 생성한다.
> 2. 서명 생성 : 생성된 해시값을 비대칭키의 개인키로 암호화하여 서명한다. 이 서명이 전자 서명이 된다
> 3. 서명 검증 : 수신자는 문서와 서명을 받아, 문서의 해시값을 새로 생성하고, 서명을 공개키로 복호화하여 원래의 해시값을 복원한다. 두 해시값이 일치하면 서명이 유효하다고 판단한다.

<br>

### 16. HTTPS 암호화 과정에 대해 설명해주세요. (SSL Handshake의 동작 과정을 설명해주세요.)
> HTTPS에서 암호화는 SSL/TLS 프로토콜을 통해 이루어지며, SSL/TLS 핸드셰이크 과정을 통해 연결을 설정하고 보안 매개변수를 협상한다.
> 
> 1. 클라이언트 헬로 (Client hello): 클라이언트는 서버에 연결 요청을 보내며, 지원하는 TLS 버전, 암호화 스위트(암호화 알고이즘 목록), 난수 값(random value) 등을 포함한다.
> 2. 서버 헬로 (Server Hello): 서버는 클라이언트의 요청을 받고, 사용할 TLS 버전, 암호화 스위트, 서버의 난수 값을 선택하여 응답한다. 또한 서버의 디지털 인증서와 서버의 공개키를 포함한다.
> 3. 서버 인증 (Server Authentication): 서버는 클라이언트에게 디지털 인증서를 보낸다. 이 인증서는 서버의 공개키와 신뢰할 수 있는 인증 기관(CA)에 의해 서명된 서버의 정보를 포함한다.
> 4. 클라이언트 키 교환 (Client Key Exchange): 클라이언트는 생성한 프리 마스터 시크릿을 공개키로 암호화하여 서버에 보낸다. 이 프리 마스터 시크릿은 이후 대칭키를 생성하는 데 사용된다.
> 5. 세션 키 생성 (Session Key Creation): 클라이언트와 서버는 프리 마스터 시크릿과 서로의 난수 값을 사용하여 대칭키(세션 키)를 생성한다. 이 대칭키는 이후 데이터 암호화에 사용된다.
> 6. 클라이언트 핸드쉐이크 완료 (Client Finished): 클라이언트는 Finished 메세지를 보내며, 이 메세지는 클라이언트와 서버가 핸드쉐이크 과정에서 설정한 모든 정보를 기반으로 데이터가 암호화되었음을 확인한다.
> 7. 서버 핸드쉐이크 완료 (Server Finished): 서버는 클라이언트의 Finished 메세지를 받고 Finished 메세지를 클라이언트에 보내며 핸드쉐이크를 완료한다. 이 메세지는 서버와 클라이언트 간의 모든 암호화 매개변수가 정확하게 설정되었음을 확인한다.
>
> 이후, 클라이언트와 서버는 생성된 세션 키를 사용하여 암호화된 데이터를 안전하게 전송할 수 있다.

<br>

## > DNS

### 17. DNS가 무엇인가요?
> DNS(Domain Name System)는 도메인 이름을 IP 주소로 변환해주는 시스템이다.
> 웹 브라우저가 도메인을 입력하면 DNS 서버가 해당 도메인에 대한 IP 주소를 반환하여, 사용자가 쉽게 웹 사이트에 접속할 수 있게 한다.

<br>

### 18. DNS 작동 방식에 대해 설명해주세요.
> 1. 도메인 이름 입력: 사용자가 웹 브라우저에 도메인 이름을 입력한다.
> 2. 재귀적 쿼리: 클라이언트의 DNS 리졸버가 요청을 받아 DNS 서버에 쿼리를 보낸다
> 3. 루트 네임서버 조회: 루트 네임서버가 요청을 수신하고, 요청된 도메인의 최상위 도메인(TLD) 네임서버를 반환한다.
> 4. TLD 네임서버 조회: TLD 네임서버가 요청을 수신하고, 도메인의 권한 있는 네임 서버를 반환한다.
> 5. 권한 있는 네임서버 조회: 권한 있는 네임서버가 IP 주소를 반환하고, 이 정보를 클라이언트의 DNS리졸버에 전달한다.
> 6. IP주소 반환: 클라이언트의 DNS리졸버가 IP 주소를 클라이언트에게 반환하여 웹사이트에 접속할 수 있게 한다.

<br>

### 19. DNS 질의 종류에 대해 설명해주세요.
> 재귀적 질의: 클라이언트가 요청한 정보를 끝까지 찾아서 반환하는 방식
> 비재귀적 질의: 클라이언트가 직접 권한 있는 DNS 서버에 요청하는 방식으로, 서버는 자신이 알고 있는 정보만 반환

<br>

### 20. DNS 서버에게 IP 주소를 요청할 때, 왜 UDP를 사용하나요?
> DNS 질의는 작은 데이터를 빠르게 전송해야 하므로, 연결 설정이 필요 없는 UDP를 사용한다.
> TCP는 연결 설정과 해제에 오버헤드가 크기 때문에 효율성이 떨어진다. 다만, 큰 데이터 전송이나 보안 강화가 필요한 경우 TCP를 사용하기도 한다.

<br>

### 21. DNS 레코드가 무엇인가요?
> DNS 레코드는 도메인과 관련된 다양한 정보를 담고 있는 항목이다.
> 대표적인 레코드로는 다음과 같다:
> 
> - A 레코드: 도메인에 대한 IPv4 주소를 나타낸다.
> - AAAA 레코드: 도메인에 대한 IPv6 주소를 나타낸다.
> - MX 레코드: 이메일 서버 정보를 나타낸다.
> - CNAME 레코드: 도메인 별칭을 나타낸다.
