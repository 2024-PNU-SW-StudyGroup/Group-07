[노션](https://observant-paper-2e3.notion.site/2-Application-Layer-1181b3bea02780b9a1cbd529a0e011e2?pvs=4)

## **📌 HTTP**

<aside>
❓

**1. HTTP 프로토콜에 대해서 설명해주세요.**

</aside>

<aside>
✅

HTTP 프로토콜은 웹에서 클라이언트와 서버 간에 데이터를 주고받기 위한 애플리케이션 계층 프로토콜입니다. 클라이언트-서버 모델을 따르며, 무상태성과 비연결성이 특징입니다. HTTP는 요청-응답 구조로 동작하며, TCP/IP 기반으로 동작합니다.

</aside>

<aside>
❓

**2. HTTP의 요청/응답 모델에 대해 설명해주세요.**

</aside>

<aside>
✅

HTTP의 요청/응답 모델은 클라이언트가 서버에 요청을 보내고, 서버가 그에 대한 응답을 보내는 구조입니다. 클라이언트의 요청은 메서드, URL, 헤더, 본문으로 구성되며, 서버의 응답은 상태 코드, 헤더, 본문으로 구성됩니다. 이 모델은 단방향 통신이며, 요청이 있어야 응답이 있습니다.

</aside>

<aside>
❓

**3. HTTP 메서드 중 GET과 POST의 차이점에 대해 설명해주세요.**

</aside>

<aside>
✅

GET은 서버로부터 정보를 조회하는 데 사용되고, POST는 서버에 데이터를 제출하는 데 사용됩니다. 그리고 관례적으로 GET은 url에 데이터를 포함하고 POST는 요청 본문 body에 포함시킵니다.

</aside>

<aside>
❓

**4. HTTP 메서드 중 PUT과 PATCH의 차이점에 대해 설명해주세요.**

</aside>

<aside>
✅

PUT은 리소스를 완전히 대체하는 데 사용되고, PATCH는 리소스의 일부를 수정하는 데 사용됩니다. 예를 들어, 사용자 엔티티의 내용을 전체 수정할때는 PUT을 사용하고 패스워드 수정만 수행할때는 PATCH를 사용합니다.

</aside>

<aside>
❓

**5. HTTP 상태 코드가 무엇인가요? 알고 있는 상태 코드 몇 가지 설명해주세요.**

</aside>

<aside>
✅

서버의 응답 상태를 나타내는 숫자입니다. 세자리 숫자로 구성되며 요청을 성공적으로 처리했을때 200, 리소스 생성을 성공했을때 201, 요청 방식이 잘못되었을때는 400, 찾을 수 없는 요청일때는 404, 마지막으로 서버의 예기치 못한 에러가 발생했을때는 500으로 반환합니다.

</aside>

<aside>
❓

**6. HTTP 헤더가 뭘까요? 알고 있는 헤더 몇 가지 설명해주세요.**

</aside>

<aside>
✅

HTTP 헤더는 HTTP의 메타데이터를 나타냅니다. 부가적인 정보를 담고있으며 제가 알고 있는 헤더로는 인증정보를 담고있는 Authorization, 본문의 타입을 담고있는 Content-type등이 있습니다.

</aside>

<aside>
❓

**7. HTTP의 무상태성에 대해서 설명해주세요.**

</aside>

<aside>
✅

HTTP의 무상태성이란 각 요청이 독립적으로 수행됨을 의미하며 이전 요청의 정보를 저장하지 않아 상태가 없음을 나타냅니다. 이로 인해 사용자 인증 유지를 위해서 쿠키나 세션, 토큰등의 방식이 필요합니다.

</aside>

<aside>
✨

**8. HTTP Keep-Alive에 대해서 설명해주세요.**

</aside>

<aside>
✅

HTTP Keep-Alive는 하나의 TCP 연결을 통해 여러 HTTP 요청/응답을 주고받을 수 있게 하는 기능입니다.

</aside>

<aside>
✨

**9. HTTP 파이프라이닝에 대해서 설명해주세요.**

</aside>

<aside>
✅

HTTP 파이프라이닝은 이전 요청의 응답을 기다리지 않고 여러 요청을 연속적으로 보내는 기술입니다. 이를 통해 네트워크 지연 시간을 줄일 수 있지만, 구현의 복잡성과 Head-of-Line Blocking 문제로 인해 널리 사용되지 않습니다.

</aside>

<aside>
✨

**10. HTTP/1.1, HTTP/2, HTTP/3 각각의 특징에 대해 설명해주세요.**

</aside>

<aside>
✅

- HTTP/1.1: 지속 연결, 파이프라이닝, 청크 전송 인코딩 지원
- HTTP/2: 멀티플렉싱, 헤더 압축, 서버 푸시 기능 추가
- HTTP/3: QUIC 프로토콜 사용, 연결 설정 시간 단축, 패킷 손실 감소
</aside>

<aside>
💡

## **HTTP/1.1**

HTTP/1.1은 가장 널리 사용되는 버전으로, 다음과 같은 특징이 있습니다:

- 지속적 연결(Persistent connections): 여러 요청을 단일 TCP 연결로 처리
- 파이프라이닝: 응답을 기다리지 않고 여러 요청을 연속해서 보낼 수 있음
- 캐싱: 캐시 제어 지시문 도입으로 클라이언트-서버 간 데이터 전송 감소
- 청크 전송 인코딩: 대용량 데이터를 청크 단위로 효율적 전송

**사용 상황:**

- 간단한 웹사이트나 API
- 레거시 시스템과의 호환성이 필요한 경우
- 제한된 리소스 환경에서 구현이 필요한 경우

예시: 텍스트 위주의 블로그 사이트나 간단한 정보 제공 웹페이지

## **HTTP/2**

HTTP/2는 성능 개선에 초점을 맞춘 버전으로, 주요 특징은 다음과 같습니다:

- 멀티플렉싱: 단일 연결로 여러 요청/응답을 동시에 처리
- 헤더 압축: HPACK 기술로 중복 헤더 정보 제거
- 서버 푸시: 클라이언트 요청 없이 서버가 리소스를 미리 전송
- 스트림 우선순위 지정: 중요한 리소스 먼저 로드 가능

**사용 상황**:

- 복잡한 웹 애플리케이션
- 모바일 환경에서의 성능 최적화가 필요한 경우
- 대량의 이미지나 비디오 콘텐츠를 제공하는 사이트

예시: 소셜 미디어 플랫폼, 온라인 쇼핑몰, 뉴스 포털 사이트

## **HTTP/3**

HTTP/3는 QUIC 프로토콜을 기반으로 하며, 다음과 같은 특징이 있습니다:

- UDP 기반: TCP 대신 UDP 사용으로 연결 설정 시간 단축
- 향상된 멀티플렉싱: 스트림 간 독립적인 패킷 손실 처리
- 0-RTT 연결 설정: 재연결 시 즉시 데이터 전송 가능
- 향상된 이동성 지원: IP 주소 변경 시에도 연결 유지

**사용 상황**:

- 초저지연이 요구되는 실시간 애플리케이션
- 모바일 네트워크 등 불안정한 연결 환경
- 대규모 글로벌 서비스로 다양한 네트워크 환경 지원 필요

예시: 실시간 스트리밍 서비스, 온라인 게임, IoT 디바이스 통신

</aside>

# **📌 HTTPS**

<aside>
❓

**11. HTTPS에 대해서 설명해주세요.**

</aside>

<aside>
✅

HTTPS는 HTTP에 보안 계층을 추가한 프로토콜입니다. HTTP는 데이터를 평문 그대로 전송하고 HTTPS는 데이터를 SSL/TLS를 사용하여 통신을 암호화하고 인증하며, 데이터의 기밀성과 무결성을 보장합니다.

</aside>

<aside>
✨

**12. SSL/TLS가 무엇인가요?**

</aside>

<aside>
✅

SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 네트워크 통신을 안전하게 만드는 암호화 프로토콜입니다. TLS는 SSL의 후속 버전으로, 현재는 TLS가 주로 사용됩니다.

</aside>

<aside>
⭐

**13. 대칭키 암호화 방식에 대해 설명해주세요.**

</aside>

<aside>
✅

대칭키 암호화는 동일한 키로 암호화와 복호화를 수행하는 방식입니다. 빠른 속도가 장점이지만, 키 교환의 안전성 확보가 어렵다는 단점이 있습니다.

</aside>

<aside>
⭐

**14. 비대칭키 암호화 방식에 대해서 설명해주세요.**

</aside>

<aside>
✅

비대칭키 암호화는 공개키와 개인키를 사용하는 방식입니다. 공개키로 암호화한 데이터는 개인키로만 복호화할 수 있습니다. 키 교환 문제를 해결하지만, 대칭키 방식보다 느립니다.

</aside>

<aside>
✨

**15. 전자 서명에 대해서 설명해주세요.**

</aside>

<aside>
✅

전자 서명은 메시지의 무결성과 발신자의 인증을 보장하는 기술입니다. 발신자의 개인키로 메시지의 해시값을 암호화하여 생성하며, 수신자는 발신자의 공개키로 이를 검증할 수 있습니다.

</aside>

<aside>
✨

**16. HTTPS 암호화 과정에 대해 설명해주세요. (SSL Handshake의 동작 과정을 설명해주세요.)**

</aside>

<aside>
✅

1. 클라이언트가 서버에 연결을 요청
2. 서버가 인증서를 클라이언트에 전송
3. 클라이언트가 인증서를 검증
4. 클라이언트가 대칭키를 생성하고 서버의 공개키로 암호화하여 전송
5. 서버가 개인키로 대칭키를 복호화
6. 이후 통신은 합의된 대칭키로 암호화
</aside>

# **📌 DNS**

<aside>
❓

**17. DNS가 무엇인가요?**

</aside>

<aside>
✅

DNS(Domain Name System)는 도메인 이름을 IP 주소로 변환하는 분산형 데이터베이스 시스템입니다.

</aside>

<aside>
❓

**18. DNS 작동 방식에 대해 설명해주세요.**

</aside>

<aside>
✅

1. 사용자가 도메인 이름을 입력
2. 로컬 DNS 서버에 쿼리
3. 루트 DNS 서버에 쿼리
4. TLD DNS 서버에 쿼리
5. 권한 있는 DNS 서버에 쿼리
6. IP 주소를 받아 클라이언트에 반환
</aside>

<aside>
❓

**19. DNS 질의 종류에 대해 설명해주세요.**

</aside>

<aside>
✨

- 재귀적 질의: DNS 서버가 다른 DNS 서버에 대신 질의하여 최종 결과를 반환
- 반복적 질의: DNS 서버가 다음 질의할 서버의 정보만 반환
</aside>

<aside>
❓

**20. DNS 서버에게 IP 주소를 요청할 때, 왜 UDP를 사용하나요?**

</aside>

<aside>
✅

UDP는 TCP와 달리 연결이 없는 프로토콜이라 빠르고 DNS 서버에 부하를 줄일 수 있어서 UDP를 사용합니다.

</aside>

<aside>
❓

**21. DNS 레코드가 무엇인가요?**

</aside>

<aside>
✅

DNS 레코드는 DNS 서버의 데이터베이스에 저장된 텍스트 형식의 지침입니다. 이 레코드들은 도메인 이름을 IP 주소로 변환하거나 다른 중요한 정보를 제공하는 역할을 합니다. 이를 통해서 DNS 서버가 사람이 읽을 수 있는 도메인 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환할 수 있습니다.

</aside>
